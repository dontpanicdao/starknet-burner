// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"sync"
)

// Ensure, that IStoreMock does implement IStore.
// If this is not the case, regenerate this file with moq.
var _ Storer = &IStoreMock{}

// IStoreMock is a mock implementation of IStore.
//
//	func TestSomethingThatUsesIStore(t *testing.T) {
//
//		// make and configure a mocked IStore
//		mockedIStore := &IStoreMock{
//			createAuthorizationFunc: func(sessionKey *Authorization) error {
//				panic("mock out the createAuthorization method")
//			},
//			createRequestFunc: func(authorizationRequest *AuthorizationRequest) error {
//				panic("mock out the createRequest method")
//			},
//			findAuthorizationFunc: func(s string) (*Authorization, error) {
//				panic("mock out the findAuthorization method")
//			},
//			findRequestFunc: func(s string) (*AuthorizationRequest, error) {
//				panic("mock out the findRequest method")
//			},
//		}
//
//		// use mockedIStore in code that requires IStore
//		// and then make assertions.
//
//	}
type IStoreMock struct {
	// createAuthorizationFunc mocks the createAuthorization method.
	createAuthorizationFunc func(sessionKey *Authorization) error

	// createRequestFunc mocks the createRequest method.
	createRequestFunc func(authorizationRequest *Request) error

	// findAuthorizationFunc mocks the findAuthorization method.
	findAuthorizationFunc func(s string) (*Authorization, error)

	// findRequestFunc mocks the findRequest method.
	findRequestFunc func(s string) (*Request, error)

	// calls tracks calls to the methods.
	calls struct {
		// createAuthorization holds details about calls to the createAuthorization method.
		createAuthorization []struct {
			// SessionKey is the sessionKey argument value.
			SessionKey *Authorization
		}
		// createRequest holds details about calls to the createRequest method.
		createRequest []struct {
			// AuthorizationRequest is the authorizationRequest argument value.
			AuthorizationRequest *Request
		}
		// findAuthorization holds details about calls to the findAuthorization method.
		findAuthorization []struct {
			// S is the s argument value.
			S string
		}
		// findRequest holds details about calls to the findRequest method.
		findRequest []struct {
			// S is the s argument value.
			S string
		}
	}
	lockcreateAuthorization sync.RWMutex
	lockcreateRequest       sync.RWMutex
	lockfindAuthorization   sync.RWMutex
	lockfindRequest         sync.RWMutex
}

// createAuthorization calls createAuthorizationFunc.
func (mock *IStoreMock) createAuthorization(sessionKey *Authorization) error {
	if mock.createAuthorizationFunc == nil {
		panic("IStoreMock.createAuthorizationFunc: method is nil but IStore.createAuthorization was just called")
	}
	callInfo := struct {
		SessionKey *Authorization
	}{
		SessionKey: sessionKey,
	}
	mock.lockcreateAuthorization.Lock()
	mock.calls.createAuthorization = append(mock.calls.createAuthorization, callInfo)
	mock.lockcreateAuthorization.Unlock()
	return mock.createAuthorizationFunc(sessionKey)
}

// createAuthorizationCalls gets all the calls that were made to createAuthorization.
// Check the length with:
//
//	len(mockedIStore.createAuthorizationCalls())
func (mock *IStoreMock) createAuthorizationCalls() []struct {
	SessionKey *Authorization
} {
	var calls []struct {
		SessionKey *Authorization
	}
	mock.lockcreateAuthorization.RLock()
	calls = mock.calls.createAuthorization
	mock.lockcreateAuthorization.RUnlock()
	return calls
}

// createRequest calls createRequestFunc.
func (mock *IStoreMock) createRequest(authorizationRequest *Request) error {
	if mock.createRequestFunc == nil {
		panic("IStoreMock.createRequestFunc: method is nil but IStore.createRequest was just called")
	}
	callInfo := struct {
		AuthorizationRequest *Request
	}{
		AuthorizationRequest: authorizationRequest,
	}
	mock.lockcreateRequest.Lock()
	mock.calls.createRequest = append(mock.calls.createRequest, callInfo)
	mock.lockcreateRequest.Unlock()
	return mock.createRequestFunc(authorizationRequest)
}

// createRequestCalls gets all the calls that were made to createRequest.
// Check the length with:
//
//	len(mockedIStore.createRequestCalls())
func (mock *IStoreMock) createRequestCalls() []struct {
	AuthorizationRequest *Request
} {
	var calls []struct {
		AuthorizationRequest *Request
	}
	mock.lockcreateRequest.RLock()
	calls = mock.calls.createRequest
	mock.lockcreateRequest.RUnlock()
	return calls
}

// findAuthorization calls findAuthorizationFunc.
func (mock *IStoreMock) findAuthorization(s string) (*Authorization, error) {
	if mock.findAuthorizationFunc == nil {
		panic("IStoreMock.findAuthorizationFunc: method is nil but IStore.findAuthorization was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockfindAuthorization.Lock()
	mock.calls.findAuthorization = append(mock.calls.findAuthorization, callInfo)
	mock.lockfindAuthorization.Unlock()
	return mock.findAuthorizationFunc(s)
}

// findAuthorizationCalls gets all the calls that were made to findAuthorization.
// Check the length with:
//
//	len(mockedIStore.findAuthorizationCalls())
func (mock *IStoreMock) findAuthorizationCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockfindAuthorization.RLock()
	calls = mock.calls.findAuthorization
	mock.lockfindAuthorization.RUnlock()
	return calls
}

// findRequest calls findRequestFunc.
func (mock *IStoreMock) findRequest(s string) (*Request, error) {
	if mock.findRequestFunc == nil {
		panic("IStoreMock.findRequestFunc: method is nil but IStore.findRequest was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockfindRequest.Lock()
	mock.calls.findRequest = append(mock.calls.findRequest, callInfo)
	mock.lockfindRequest.Unlock()
	return mock.findRequestFunc(s)
}

// findRequestCalls gets all the calls that were made to findRequest.
// Check the length with:
//
//	len(mockedIStore.findRequestCalls())
func (mock *IStoreMock) findRequestCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockfindRequest.RLock()
	calls = mock.calls.findRequest
	mock.lockfindRequest.RUnlock()
	return calls
}
