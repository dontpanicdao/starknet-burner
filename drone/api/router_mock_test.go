// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"sync"
)

// Ensure, that IStoreMock does implement IStore.
// If this is not the case, regenerate this file with moq.
var _ IStore = &IStoreMock{}

// IStoreMock is a mock implementation of IStore.
//
//	func TestSomethingThatUsesIStore(t *testing.T) {
//
//		// make and configure a mocked IStore
//		mockedIStore := &IStoreMock{
//			createRequestFunc: func(request *Request) error {
//				panic("mock out the createRequest method")
//			},
//			readRequestFunc: func(s string) (*Request, error) {
//				panic("mock out the readRequest method")
//			},
//			readSessionTokenFunc: func(s string) (*SessionKey, error) {
//				panic("mock out the readSessionToken method")
//			},
//			updateSessionTokenFunc: func(sessionKey *SessionKey) error {
//				panic("mock out the updateSessionToken method")
//			},
//		}
//
//		// use mockedIStore in code that requires IStore
//		// and then make assertions.
//
//	}
type IStoreMock struct {
	// createRequestFunc mocks the createRequest method.
	createRequestFunc func(request *Request) error

	// readRequestFunc mocks the readRequest method.
	readRequestFunc func(s string) (*Request, error)

	// readSessionTokenFunc mocks the readSessionToken method.
	readSessionTokenFunc func(s string) (*SessionKey, error)

	// updateSessionTokenFunc mocks the updateSessionToken method.
	updateSessionTokenFunc func(sessionKey *SessionKey) error

	// calls tracks calls to the methods.
	calls struct {
		// createRequest holds details about calls to the createRequest method.
		createRequest []struct {
			// Request is the request argument value.
			Request *Request
		}
		// readRequest holds details about calls to the readRequest method.
		readRequest []struct {
			// S is the s argument value.
			S string
		}
		// readSessionToken holds details about calls to the readSessionToken method.
		readSessionToken []struct {
			// S is the s argument value.
			S string
		}
		// updateSessionToken holds details about calls to the updateSessionToken method.
		updateSessionToken []struct {
			// SessionKey is the sessionKey argument value.
			SessionKey *SessionKey
		}
	}
	lockcreateRequest      sync.RWMutex
	lockreadRequest        sync.RWMutex
	lockreadSessionToken   sync.RWMutex
	lockupdateSessionToken sync.RWMutex
}

// createRequest calls createRequestFunc.
func (mock *IStoreMock) createRequest(request *Request) error {
	if mock.createRequestFunc == nil {
		panic("IStoreMock.createRequestFunc: method is nil but IStore.createRequest was just called")
	}
	callInfo := struct {
		Request *Request
	}{
		Request: request,
	}
	mock.lockcreateRequest.Lock()
	mock.calls.createRequest = append(mock.calls.createRequest, callInfo)
	mock.lockcreateRequest.Unlock()
	return mock.createRequestFunc(request)
}

// createRequestCalls gets all the calls that were made to createRequest.
// Check the length with:
//
//	len(mockedIStore.createRequestCalls())
func (mock *IStoreMock) createRequestCalls() []struct {
	Request *Request
} {
	var calls []struct {
		Request *Request
	}
	mock.lockcreateRequest.RLock()
	calls = mock.calls.createRequest
	mock.lockcreateRequest.RUnlock()
	return calls
}

// readRequest calls readRequestFunc.
func (mock *IStoreMock) readRequest(s string) (*Request, error) {
	if mock.readRequestFunc == nil {
		panic("IStoreMock.readRequestFunc: method is nil but IStore.readRequest was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockreadRequest.Lock()
	mock.calls.readRequest = append(mock.calls.readRequest, callInfo)
	mock.lockreadRequest.Unlock()
	return mock.readRequestFunc(s)
}

// readRequestCalls gets all the calls that were made to readRequest.
// Check the length with:
//
//	len(mockedIStore.readRequestCalls())
func (mock *IStoreMock) readRequestCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockreadRequest.RLock()
	calls = mock.calls.readRequest
	mock.lockreadRequest.RUnlock()
	return calls
}

// readSessionToken calls readSessionTokenFunc.
func (mock *IStoreMock) readSessionToken(s string) (*SessionKey, error) {
	if mock.readSessionTokenFunc == nil {
		panic("IStoreMock.readSessionTokenFunc: method is nil but IStore.readSessionToken was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockreadSessionToken.Lock()
	mock.calls.readSessionToken = append(mock.calls.readSessionToken, callInfo)
	mock.lockreadSessionToken.Unlock()
	return mock.readSessionTokenFunc(s)
}

// readSessionTokenCalls gets all the calls that were made to readSessionToken.
// Check the length with:
//
//	len(mockedIStore.readSessionTokenCalls())
func (mock *IStoreMock) readSessionTokenCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockreadSessionToken.RLock()
	calls = mock.calls.readSessionToken
	mock.lockreadSessionToken.RUnlock()
	return calls
}

// updateSessionToken calls updateSessionTokenFunc.
func (mock *IStoreMock) updateSessionToken(sessionKey *SessionKey) error {
	if mock.updateSessionTokenFunc == nil {
		panic("IStoreMock.updateSessionTokenFunc: method is nil but IStore.updateSessionToken was just called")
	}
	callInfo := struct {
		SessionKey *SessionKey
	}{
		SessionKey: sessionKey,
	}
	mock.lockupdateSessionToken.Lock()
	mock.calls.updateSessionToken = append(mock.calls.updateSessionToken, callInfo)
	mock.lockupdateSessionToken.Unlock()
	return mock.updateSessionTokenFunc(sessionKey)
}

// updateSessionTokenCalls gets all the calls that were made to updateSessionToken.
// Check the length with:
//
//	len(mockedIStore.updateSessionTokenCalls())
func (mock *IStoreMock) updateSessionTokenCalls() []struct {
	SessionKey *SessionKey
} {
	var calls []struct {
		SessionKey *SessionKey
	}
	mock.lockupdateSessionToken.RLock()
	calls = mock.calls.updateSessionToken
	mock.lockupdateSessionToken.RUnlock()
	return calls
}
