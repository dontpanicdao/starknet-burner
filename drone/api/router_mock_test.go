// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"sync"
)

// Ensure, that IStoreMock does implement IStore.
// If this is not the case, regenerate this file with moq.
var _ IStore = &IStoreMock{}

// IStoreMock is a mock implementation of IStore.
//
//	func TestSomethingThatUsesIStore(t *testing.T) {
//
//		// make and configure a mocked IStore
//		mockedIStore := &IStoreMock{
//			downloadRequestFunc: func(s string) (*Request, error) {
//				panic("mock out the downloadRequest method")
//			},
//			downloadSessionTokenFunc: func(s string) (*SessionKey, error) {
//				panic("mock out the downloadSessionToken method")
//			},
//			uploadRequestFunc: func(request *Request) error {
//				panic("mock out the uploadRequest method")
//			},
//			uploadSessionTokenFunc: func(sessionKey *SessionKey) error {
//				panic("mock out the uploadSessionToken method")
//			},
//		}
//
//		// use mockedIStore in code that requires IStore
//		// and then make assertions.
//
//	}
type IStoreMock struct {
	// downloadRequestFunc mocks the downloadRequest method.
	downloadRequestFunc func(s string) (*Request, error)

	// downloadSessionTokenFunc mocks the downloadSessionToken method.
	downloadSessionTokenFunc func(s string) (*SessionKey, error)

	// uploadRequestFunc mocks the uploadRequest method.
	uploadRequestFunc func(request *Request) error

	// uploadSessionTokenFunc mocks the uploadSessionToken method.
	uploadSessionTokenFunc func(sessionKey *SessionKey) error

	// calls tracks calls to the methods.
	calls struct {
		// downloadRequest holds details about calls to the downloadRequest method.
		downloadRequest []struct {
			// S is the s argument value.
			S string
		}
		// downloadSessionToken holds details about calls to the downloadSessionToken method.
		downloadSessionToken []struct {
			// S is the s argument value.
			S string
		}
		// uploadRequest holds details about calls to the uploadRequest method.
		uploadRequest []struct {
			// Request is the request argument value.
			Request *Request
		}
		// uploadSessionToken holds details about calls to the uploadSessionToken method.
		uploadSessionToken []struct {
			// SessionKey is the sessionKey argument value.
			SessionKey *SessionKey
		}
	}
	lockdownloadRequest      sync.RWMutex
	lockdownloadSessionToken sync.RWMutex
	lockuploadRequest        sync.RWMutex
	lockuploadSessionToken   sync.RWMutex
}

// downloadRequest calls downloadRequestFunc.
func (mock *IStoreMock) downloadRequest(s string) (*Request, error) {
	if mock.downloadRequestFunc == nil {
		panic("IStoreMock.downloadRequestFunc: method is nil but IStore.downloadRequest was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockdownloadRequest.Lock()
	mock.calls.downloadRequest = append(mock.calls.downloadRequest, callInfo)
	mock.lockdownloadRequest.Unlock()
	return mock.downloadRequestFunc(s)
}

// downloadRequestCalls gets all the calls that were made to downloadRequest.
// Check the length with:
//
//	len(mockedIStore.downloadRequestCalls())
func (mock *IStoreMock) downloadRequestCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockdownloadRequest.RLock()
	calls = mock.calls.downloadRequest
	mock.lockdownloadRequest.RUnlock()
	return calls
}

// downloadSessionToken calls downloadSessionTokenFunc.
func (mock *IStoreMock) downloadSessionToken(s string) (*SessionKey, error) {
	if mock.downloadSessionTokenFunc == nil {
		panic("IStoreMock.downloadSessionTokenFunc: method is nil but IStore.downloadSessionToken was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockdownloadSessionToken.Lock()
	mock.calls.downloadSessionToken = append(mock.calls.downloadSessionToken, callInfo)
	mock.lockdownloadSessionToken.Unlock()
	return mock.downloadSessionTokenFunc(s)
}

// downloadSessionTokenCalls gets all the calls that were made to downloadSessionToken.
// Check the length with:
//
//	len(mockedIStore.downloadSessionTokenCalls())
func (mock *IStoreMock) downloadSessionTokenCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockdownloadSessionToken.RLock()
	calls = mock.calls.downloadSessionToken
	mock.lockdownloadSessionToken.RUnlock()
	return calls
}

// uploadRequest calls uploadRequestFunc.
func (mock *IStoreMock) uploadRequest(request *Request) error {
	if mock.uploadRequestFunc == nil {
		panic("IStoreMock.uploadRequestFunc: method is nil but IStore.uploadRequest was just called")
	}
	callInfo := struct {
		Request *Request
	}{
		Request: request,
	}
	mock.lockuploadRequest.Lock()
	mock.calls.uploadRequest = append(mock.calls.uploadRequest, callInfo)
	mock.lockuploadRequest.Unlock()
	return mock.uploadRequestFunc(request)
}

// uploadRequestCalls gets all the calls that were made to uploadRequest.
// Check the length with:
//
//	len(mockedIStore.uploadRequestCalls())
func (mock *IStoreMock) uploadRequestCalls() []struct {
	Request *Request
} {
	var calls []struct {
		Request *Request
	}
	mock.lockuploadRequest.RLock()
	calls = mock.calls.uploadRequest
	mock.lockuploadRequest.RUnlock()
	return calls
}

// uploadSessionToken calls uploadSessionTokenFunc.
func (mock *IStoreMock) uploadSessionToken(sessionKey *SessionKey) error {
	if mock.uploadSessionTokenFunc == nil {
		panic("IStoreMock.uploadSessionTokenFunc: method is nil but IStore.uploadSessionToken was just called")
	}
	callInfo := struct {
		SessionKey *SessionKey
	}{
		SessionKey: sessionKey,
	}
	mock.lockuploadSessionToken.Lock()
	mock.calls.uploadSessionToken = append(mock.calls.uploadSessionToken, callInfo)
	mock.lockuploadSessionToken.Unlock()
	return mock.uploadSessionTokenFunc(sessionKey)
}

// uploadSessionTokenCalls gets all the calls that were made to uploadSessionToken.
// Check the length with:
//
//	len(mockedIStore.uploadSessionTokenCalls())
func (mock *IStoreMock) uploadSessionTokenCalls() []struct {
	SessionKey *SessionKey
} {
	var calls []struct {
		SessionKey *SessionKey
	}
	mock.lockuploadSessionToken.RLock()
	calls = mock.calls.uploadSessionToken
	mock.lockuploadSessionToken.RUnlock()
	return calls
}
